
###########################General information###################
#000 ——> z=3
#001 ——> z=2
#002 ——> z=1
#003 ——> z=0.5
#004 ——> z=0

###########################To import the particle data###################
import readgadget
import numpy as np
import MAS_library as MASL

# input files
snapshot = '/Users/finlaysime/Desktop/Senior Honour Project/snapdir_004/snap_004'
print("snapshot files imported")

#[1](CDM), [2](neutrinos) or [1,2](CDM+neutrinos)
     
ptype_CDM = [1]
ptype_Neutrino = [2]
ptype_CDM_and_Neutrino = [1,2]

# read header
header   = readgadget.header(snapshot)
BoxSize  = header.boxsize/1e3  #Mpc/h
Nall     = header.nall         #Total number of particles
Masses   = header.massarr*1e10 #Masses of the particles in Msun/h
Omega_m  = header.omega_m      #value of Omega_m
Omega_l  = header.omega_l      #value of Omega_l
h        = header.hubble       #value of h
redshift = header.redshift     #redshift of the snapshot
Hubble   = 100.0*np.sqrt(Omega_m*(1.0+redshift)**3+Omega_l)#Value of H(z) in km/s/(Mpc/h)

# read positions, velocities and IDs of the particles
pos_CDM = readgadget.read_block(snapshot, "POS ", ptype_CDM)/1e3 #positions in Mpc/h
vel_CDM = readgadget.read_block(snapshot, "VEL ", ptype_CDM)     #peculiar velocities in km/s
ids_CDM = readgadget.read_block(snapshot, "ID  ", ptype_CDM)-1

pos_Neutrino = readgadget.read_block(snapshot, "POS ", ptype_Neutrino)/1e3
vel_Neutrino = readgadget.read_block(snapshot, "VEL ", ptype_Neutrino)
ids_Neutrino = readgadget.read_block(snapshot, "ID  ", ptype_Neutrino)-1

pos_CDM_and_Neutrino = readgadget.read_block(snapshot, "POS ", ptype_CDM_and_Neutrino)/1e3
vel_CDM_and_Neutrino = readgadget.read_block(snapshot, "VEL ", ptype_CDM_and_Neutrino)
ids_CDM_and_Neutrino = readgadget.read_block(snapshot, "ID  ", ptype_CDM_and_Neutrino)-1
print("Positions & velocities acquired")

#############################To get the halo catalog######################################
f_catalog = '/Users/finlaysime/Desktop/Senior Honour Project/halos/1/out_4_pid.list' 

# read the halo catalog
data = np.loadtxt(f_catalog)
print("Halo data imported")

pid  = data[:,41]
idx = pid == -1  #ids of the halos
data_halo = data[idx]

#Units: Masses in Msun / h
#Units: Positions in Mpc / h (comoving)
#Units: Velocities in km / s (physical, peculiar)
#BoxSize=1000.0

halo_pos = data_halo[:,8:11]
halo_velocity = data_halo[:,11:14]
halo_mass = data_halo[:,2]
print("Halo positions, velocites, & masses acquired")

#############################Build density field######################################
grid_CDM = int(input("Grid size CDM: ")) #the density field will have grid^3 voxels
# (tutorial gave 512, Yan-Chuan said 128 for neutrinos possibly)
grid_N = int(input("Grid size Neutrinos: "))
grid_CDM_N = int(input("Grid size CDM & Neutrinos: "))
MAS = 'CIC' #Mass-assignment scheme:'NGP', 'CIC', 'TSC', 'PCS'
verbose = True #whether to print information about progress

#Print some information
print('BoxSize: %.3f Mpc/h'%BoxSize)
print('Redshift: %.3f'%redshift)
print('CDM:')
print('%.3f < X < %.3f'%(np.min(pos_CDM[:,0]), np.max(pos_CDM[:,0])))
print('%.3f < Y < %.3f'%(np.min(pos_CDM[:,1]), np.max(pos_CDM[:,1])))
print('%.3f < Z < %.3f'%(np.min(pos_CDM[:,2]), np.max(pos_CDM[:,2])))
print('NEUTRINOS:')
print('%.3f < X < %.3f'%(np.min(pos_Neutrino[:,0]), np.max(pos_Neutrino[:,0])))
print('%.3f < Y < %.3f'%(np.min(pos_Neutrino[:,1]), np.max(pos_Neutrino[:,1])))
print('%.3f < Z < %.3f'%(np.min(pos_Neutrino[:,2]), np.max(pos_Neutrino[:,2])))
print('CDM & NEUTRINOS:')
print('%.3f < X < %.3f'%(np.min(pos_CDM_and_Neutrino[:,0]), np.max(pos_CDM_and_Neutrino[:,0])))
print('%.3f < Y < %.3f'%(np.min(pos_CDM_and_Neutrino[:,1]), np.max(pos_CDM_and_Neutrino[:,1])))
print('%.3f < Z < %.3f'%(np.min(pos_CDM_and_Neutrino[:,2]), np.max(pos_CDM_and_Neutrino[:,2])))

# create the 3D array to hold data in
delta_pos_CDM = np.zeros((grid_CDM,grid_CDM,grid_CDM), dtype=np.float32)
delta_pos_Neutrino = np.zeros((grid_N,grid_N,grid_N), dtype=np.float32)
delta_pos_CDM_and_Neutrino = np.zeros((grid_CDM_N,grid_CDM_N,grid_CDM_N), dtype=np.float32)


# construct 3D density field

# assign mass to 3D array to create a density field
MASL.MA(pos_CDM, delta_pos_CDM, BoxSize, MAS, verbose=verbose)
MASL.MA(pos_Neutrino, delta_pos_Neutrino, BoxSize, MAS, verbose=verbose)
MASL.MA(pos_CDM_and_Neutrino, delta_pos_CDM_and_Neutrino, BoxSize, MAS, verbose=verbose)

# the sum of the values in all voxels should be equal to the number of particles
print('%.3f should be equal to\n%.3f'%(np.sum(delta_pos_CDM, dtype=np.float64), pos_CDM.shape[0]))

delta_pos_CDM *= Masses[1]
delta_pos_Neutrino *= Masses[1]
delta_pos_CDM_and_Neutrino *= Masses[1]

# now check that the total mass in the density field is equal to the total mass in the
# simulation
print('%.3e should be equal to\n%.3e'%(np.sum(delta_pos_CDM, dtype=np.float64),
                                       pos_CDM.shape[0]*Masses[1]))


# box is 1000Mpc/hand each voxel is ~2Mpc/h (for grid of 512).  So if we take 5 slices we can consider
# a region that has ~10Mpc/h in width.


size_CDM = BoxSize / grid_CDM
size_N = BoxSize / grid_N
size_CDM_N = BoxSize / grid_CDM_N
print(f"Voxel size in CDM is {size_CDM}Mpc/h")
print(f"Voxel size in Neutrinos is {size_N}Mpc/h")
print(f"Voxel size in CDM & Neutrino is {size_CDM_N}Mpc/h")
while True:
    Slice_CDM = int(input("No. of slices for CDM: "))
    Slice_N = int(input("No. of slices for Neutrinos: "))
    Slice_CDMandN = int(input("No. of slices for CDM and Neutrinos: "))

    
    if isinstance(Slice_CDM, int) and isinstance(Slice_N, int) and isinstance(Slice_CDMandN, int):
        break
    else:
        print("Invalid input, please enter an integer")

slice_thickness_CDM = Slice_CDM * size_CDM
slice_thickness_N = Slice_N * size_N
slice_thickness_CDM_N = Slice_CDMandN * size_CDM_N
print(f"CDM slice thickness: {slice_thickness_CDM} Mpc/h")
print(f"Neutrino slice thickness: {slice_thickness_N} Mpc/h")
print(f"CDM & neutrino slice thickness: {slice_thickness_CDM_N} Mpc/h")

#Take the first 5 components along the first axis and compute the mean value
mean_density_CDM = np.mean(delta_pos_CDM[:Slice_CDM,:,:],axis=0)
mean_density_Neutrino = np.mean(delta_pos_Neutrino[:Slice_N,:,:],axis=0)
mean_density_CDM_and_Neutrino = np.mean(delta_pos_CDM_and_Neutrino[:Slice_CDMandN,:,:],axis=0)

print('Image shape:',mean_density_CDM.shape)
print('%.3e < mass < %.3e'%(np.min(mean_density_CDM), np.max(mean_density_CDM)))

print("CDM:")
# now lets consider the particles in that slide
indexes_CDM = np.where((pos_CDM[:,0]<slice_thickness_CDM))
pos_slide_CDM = pos_CDM[indexes_CDM]
print('%.3f < X < %.3f'%(np.min(pos_slide_CDM[:,0]), np.max(pos_slide_CDM[:,0])))
print('%.3f < Y < %.3f'%(np.min(pos_slide_CDM[:,1]), np.max(pos_slide_CDM[:,1])))
print('%.3f < Z < %.3f'%(np.min(pos_slide_CDM[:,2]), np.max(pos_slide_CDM[:,2])))
print('')

print("NEUTRINOS:")
#indexes_Neutrino = np.where((pos_Neutrino[:,0]<slice_thickness_N))
indexes_Neutrino = np.where((pos_Neutrino[:,0]<10))
pos_slide_Neutrino = pos_CDM[indexes_Neutrino]
print('%.3f < X < %.3f'%(np.min(pos_slide_Neutrino[:,0]), np.max(pos_slide_Neutrino[:,0])))
print('%.3f < Y < %.3f'%(np.min(pos_slide_Neutrino[:,1]), np.max(pos_slide_Neutrino[:,1])))
print('%.3f < Z < %.3f'%(np.min(pos_slide_Neutrino[:,2]), np.max(pos_slide_Neutrino[:,2])))
print('')

print("CDM & NEUTRINOS:")
indexes_CDM_and_Neutrino = np.where((pos_CDM_and_Neutrino[:,0]<slice_thickness_CDM_N))
pos_slide_CDM_and_Neutrino = pos_CDM_and_Neutrino[indexes_CDM_and_Neutrino]
print('%.3f < X < %.3f'%(np.min(pos_slide_CDM_and_Neutrino[:,0]),
                         np.max(pos_slide_CDM_and_Neutrino[:,0])))
print('%.3f < Y < %.3f'%(np.min(pos_slide_CDM_and_Neutrino[:,1]),
                         np.max(pos_slide_CDM_and_Neutrino[:,1])))
print('%.3f < Z < %.3f'%(np.min(pos_slide_CDM_and_Neutrino[:,2]),
                         np.max(pos_slide_CDM_and_Neutrino[:,2])))

#################################Draw Density Fields#####################################
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
from scipy.stats import *
from pylab import *

def draw_density_field1(ax, mean_density):
    # Creates a gridded 2D slice of the mass-assigned density field

    divider = make_axes_locatable(ax)
    
    ax_cb = divider.append_axes("right", size="5%", pad=0.05)
    fig = ax.get_figure()
    fig.add_axes(ax_cb)
    
    im = ax.imshow(mean_density.T, cmap='gnuplot', vmin=0.0, vmax=1e13, origin='lower')
    
    plt.colorbar(im, cax=ax_cb)
    ax_cb.yaxis.tick_right()
    
def draw_density_field2(ax, pos_slide):
    # Create a scatter plot of every particles position
    divider = make_axes_locatable(ax)
    
    ax_cb = divider.append_axes("right", size="5%", pad=0.05)
    fig = ax.get_figure()
    fig.add_axes(ax_cb)

    #Bin data to produce a colour density, loses some resolution however increasing the gridsize
    #makes the image blank
    ax.hexbin(pos_slide[:,1], pos_slide[:,2], gridsize=75, cmap='viridis')
    plt.colorbar(ax.collections[0], cax=ax_cb)

    #####################################################
    
    # This method has a runtime that is too long for my laptop to process,
    # however I think it is likely better/more detailed than the one used above.
    
    #values = np.vstack([pos_slide[:,1], pos_slide[:,2]])
    #density_values = gaussian_kde(values)(values)
    #kde = kernel.evaluate(kernel)
    #im = ax.scatter(pos_slide[:,1], pos_slide[:,2], s=0.001, c=density_values,
    #                cmap='viridis')
    #plt.colorbar(im, cax=ax_cb)
    #ax_cb.yaxis.tick_right()
    ####################################################
    
def draw_density_fields():
    fig = figure(layout='tight', figsize=(20,20))
    axs = fig.subplot_mosaic([["CDM_1", "CDM_2"],
                         ["Neutrino_1", "Neutrino_2"],
                         ["CDM&N_1", "CDM&N_2"]])
    
    #CDM
    ax_cdm1 = axs["CDM_1"]
    ax_cdm2 = axs["CDM_2"]
    
    draw_density_field1(ax_cdm1, mean_density_CDM)
    ax_cdm1.set_xlabel('Mpc/h')
    ax_cdm1.set_ylabel('Mpc/h')
    ax_cdm1.set_title("Desnity field of CDM by mass assignment scheme")
    
    draw_density_field2(ax_cdm2, pos_slide_CDM)
    ax_cdm2.set_xlabel('Mpc/h')
    ax_cdm2.set_ylabel('Mpc/h')
    ax_cdm2.set_title("Density field of CDM by plt.hexbin")
    ax_cdm2.set_aspect('equal')
    
    #NEUTRINOS
    ax_neu1 = axs["Neutrino_1"]
    ax_neu2 = axs["Neutrino_2"]
    
    draw_density_field1(ax_neu1, mean_density_Neutrino)
    ax_neu1.set_xlabel('Mpc/h')
    ax_neu1.set_ylabel('Mpc/h')
    ax_neu1.set_title("Density field of Neutrinos by mass assignment scheme")

    draw_density_field2(ax_neu2, pos_slide_Neutrino)
    ax_neu2.set_xlabel('Mpc/h')
    ax_neu2.set_ylabel('Mpc/h')
    ax_neu2.set_title("Density field of Neutrinos by plt.hexbin")
    ax_neu2.set_aspect('equal')
    
    #CDM & NEUTRINOS
    ax_cdmAndN1 = axs["CDM&N_1"]
    ax_cdmAndN2 = axs["CDM&N_2"]
    
    draw_density_field1(ax_cdmAndN1, mean_density_CDM_and_Neutrino)
    ax_cdmAndN1.set_xlabel('Mpc/h')
    ax_cdmAndN1.set_ylabel('Mpc/h')
    ax_cdmAndN1.set_title("Desnity field of CDM & Neutrinos by mass assignment scheme")
    
    draw_density_field2(ax_cdmAndN2, pos_slide_CDM_and_Neutrino)
    ax_cdmAndN2.set_xlabel('Mpc/h')
    ax_cdmAndN2.set_ylabel('Mpc/h')
    ax_cdmAndN2.set_title("Density field of CDM & Neutrinos by plt.hexbin")
    ax_cdmAndN2.set_aspect('equal')
    
    plt.show()

draw_density_fields()
